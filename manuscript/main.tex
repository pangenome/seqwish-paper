\PassOptionsToPackage{utf8}{inputenc}
\documentclass{bioinfo}

\usepackage[draft]{hyperref}
\usepackage{makecell}
\usepackage{comment}

\usepackage{floatrow}

% singlelinecheck=false puts subcaptions on the left
\usepackage[singlelinecheck=false]{subcaption}

\usepackage{algorithm2e}
\usepackage[usenames,dvipsnames]{xcolor}

% we squeeze our figures even more together
\captionsetup{belowskip=-2pt}

\SetAlgoLined
\SetKwProg{MyStruct}{Struct}{ contains}{end}

\newcommand{\vocab}{\textbf}
\newcommand{\red}[1]{{\textcolor{Red}{#1}}}
\newcommand{\FIXME}[1]{\red{[FIXME: #1]}}

\def\labelitemi{--}

\copyrightyear{2021} \pubyear{XXXX}

\access{Advance Access Publication Date: Day Month Year}
\appnotes{Genome Analysis}

\begin{document}
    \firstpage{1}

    \subtitle{Genome Analysis}

    \title[seqwish: very large variation graph inducer]{seqwish: very large variation graph inducer}
    \author[Garrison \textit{et~al}.]{
        Erik~Garrison\,$^{\text{\sfb 1} \dagger*}$
    }

    \address{
        $^{\text{\sf 1}}$University of Tennessee Health Science Center, Memphis, TN, USA
    }

    \corresp{$^\ast$To whom correspondence should be addressed. \\
        $^\dagger$Contributed equally.}

    \history{Received on XXXXX; revised on XXXXX; accepted on XXXXX}

    \editor{Associate Editor: XXXXXXX}

    \abstract{
        \textbf{Motivation:}
        ... \\
        \textbf{Results:}
        We wrote seqwish, a novel ... \\
        \textbf{Availability:}
        seqwish is published as free software under the MIT open source license.
        Source code and documentation are available at \url{https://github.com/ekg/seqwish}.
        seqwish can be installed via Bioconda \url{https://bioconda.github.io/recipes/seqwish/README.html} or GNU Guix \url{https://github.com/ekg/guix-genomics/blob/master/seqwish.scm}. \\
        \textbf{Contact:} \href{egarris5@uthsc.edu}{egarris5@uthsc.edu} \\
%\textbf{Supplementary information:} Supplementary data are available at \textit{Bioinformatics} online.
    }

    \maketitle


    \section{Introduction}
    \label{sec:introduction}
    \FIXME{to do}


    \section{Model}
    \label{sec:model}

    A set of pairwise alignments imply a variation graph, however I know of no contained method that will generate the variation graph or lossless string graph from these alignments.
    To explore this, I developed an algorithm to do so that operates in external memory, which I here present in detail.
    It operates by conversion of the alignment set into an alignment graph and the subsequent use of this graph in the elaboration of the variation graph including paths representing the input sequences.
    The resulting graph is a lossless representation of the input and the alignments between them.
    To distinguish the approach from string graphs, which imply error correction, I call this variation graph induction model the \emph{squish graph}.

    \texttt{seqwish} implements a lossless conversion from pairwise alignments between sequences to a variation graph encoding the sequences and their alignments.
    As input, we typically take all-versus-all alignments, but the exact structure of the alignment set may be defined in an application specific way.
    \texttt{seqwish} uses a series of disk-backed sorts and passes over the alignment and sequence inputs to allow the graph to be constructed in low memory relative to the size of the input sequence set.
    Memory usage during construction and traversal is limited by the use of sorted disk-backed arrays and succinct rank/select dictionaries to record a queryable version of the graph.


    \section{Implementation}
    \label{sec:implementation}
    As input, we have $Q$, which is a concatenation of the sequences from which we will build the graph.
    We build a compressed suffix array (CSA) mapping sequence names to offsets in $Q$, and also the inverse using a rank/select dictionary on a bitvector marking the starts of sequences in $Q$.
    This allows us to map between positions in the sequences of $Q$, which is the format in which alignment algorithms typically express alignments, and positions in $Q$ itself, which is the coordinate space we will use as a basis for the generation of our graph.
    We encode the set of input pairwise alignments between sequences in $Q$ as object $A$.
    Although these alignments tend to be represented using oriented interval pairs in $Q$, for simplicity and robustness to graph complexity, we describe $A$ as a set of pairs of bidirectional positions (sequence offsets and strands) $[1 \ldots |Q_1 \ldots Q_{|Q|}|]$ , such that $A = \{ (b_{q}, b_{r}), \ldots \}$.
    We sort $A$ by the first member ($b_{q}$) of each pair, ensuring that the entries in $A$ are ordered according to their order in $Q$.

    To query the induced graph we build a rank/select dictionary allowing efficient traversal of $A$, based on a bit vector $A_{bv}$ of the same length as $A$ such that we record a 1 at those positions which correspond to the first instance of a given $b_{q}$ and record a 0 in $A_{bv}$ otherwise.
    We record which $b_{q}$ we have processed in the bitvector $Q_{seen}$ which is of the same length as $Q$.
    This allows us to avoid a quadratic penalty in the order of the size of the transitive closures in $Q$ generated by pairs in $A$.

    Now we inductively derive the graph implied by the alignments.
    For each base $b_{q}$ in $Q$ not already marked in $Q_{seen}$, we find its transitive closure $c_{q} := \{b_{q}, b_{r_{1}}, \ldots \}$ by traversing aligned base pairs recorded in $A$.
    We write the character of the base $b_{q}$ to an entry $s_i$ in a vector $S$, then for each $b_{c}$ in $c_{q}$ we record a pair $(s_{i}, b_{c})$ into $N$ and its reverse, $(b_{c}, s_{i})$ into $P$.
    We mark $Q_{seen}$ for each base in each emitted cluster, so that we will not consider these bases in subsequent transitive closures.
    By sorting $N$ and $P$ by their first entries, we can build rank/select dictionaries on them akin to that we built on $A$ that allow random access by graph base (as given in $S$) or input base (as given in $Q$).

    To fully induce the variation graph we need to establish the links between bases in $S$ that would be required for us to find any sequence in the input as a walk through the graph.
    We do so by rewriting $Q$ (in both the forward and reverse orientation) in terms of pairs of bases in $S$, then sorting the resulting pairs by their first element, which yields $L = [(b_{a}, b_{b}), \ldots ]$.
    These pairs record the links and their frequencies, which we can emit or filter (such as by frequency) as needed in particular applications.
    In typical use we take the graph to be given by the unique elements of $L$.

    Our data model encodes the graph using single-base nodes, but often downstream use requires identifying nodes and thus we benefit from compressing the unitigs of the graph into single nodes, which reduces memory used by identifiers in analysis.
    We can compress the node space of the graph by traversing $S$, and for each base querying the inbound links.
    Maintaining a bitvector $S_{id}$ of length equal to $S$ we mark each base at which we see any link other than one from or to the previous base on the forward or reverse strand, or at bases where we have no incoming links.
    By building a rank/select dictionary on $S_{id}$ we can assign a smaller set of node ids to the sequence space of the graph.

    Given the id space encoded by $S_{id}$ we can materialize the graph in a variety of interchange formats, or provide id-based interfaces to the indexed squish graph.
    To generate graphs in \texttt {vg} or GFA format, we want to decompose the graph into its nodes ($S$), edges ($L$) and paths ($P$).
    The nodes are given by $S$ and $S_{id}$, and similarly we project $L$ and $P$ through $S_{id}$ to obtain a compressed variation graph.


    \section{Results}
    \label{sec:results}
    \FIXME{to do}

    \subsection{subsection 1}
    \label{subsec:subsec1}
    \FIXME{to do}


    \section{Discussion}
    \label{sec:discussion}
    \FIXME{to do}

    \section*{Acknowledgements}

    We thank members of the HPRC production teams for their development of resources used in our exposition.

    \section*{Funding}

    We gratefully acknowledge support from NIH/NIDA U01DA047638 (EG).

    \section*{Data availability}

    Code and links to data resources used to build this manuscript and its figures, can be found in the paper's public repository: \url{https://github.com/pangenome/seqwish-paper}.

    \bibliographystyle{natbib}

    \bibliography{document}

\end{document}
