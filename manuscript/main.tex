\PassOptionsToPackage{utf8}{inputenc}
\documentclass{bioinfo}

\usepackage[draft]{hyperref}
\usepackage{makecell}
\usepackage{comment}

\usepackage{floatrow}

\usepackage{comment}

% singlelinecheck=false puts subcaptions on the left
\usepackage[singlelinecheck=false]{subcaption}

\usepackage{algorithm2e}
\usepackage[usenames,dvipsnames]{xcolor}

\usepackage{amsthm}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

% we squeeze our figures even more together
\captionsetup{belowskip=-2pt}

\SetAlgoLined
\SetKwProg{MyStruct}{Struct}{ contains}{end}

\newcommand{\vocab}{\textbf}
\newcommand{\red}[1]{{\textcolor{Red}{#1}}}
\newcommand{\FIXME}[1]{\red{[FIXME: #1]}}

\def\labelitemi{--}

\copyrightyear{2021} \pubyear{XXXX}

\access{Advance Access Publication Date: Day Month Year}
\appnotes{Genome Analysis}

\begin{document}
\firstpage{1}

\subtitle{Genome Analysis}

\title[Multi-reference pangenome graphs]{Multi-reference pangenome graphs}
\author[Garrison \textit{et~al}.]{
Erik~Garrison\,$^{\text{\sfb 1}*}$,
Andrea~Guarracino\,$^{\text{\sfb 2}}$
}

\address{
$^{\text{\sf 1}}$University of Tennessee Health Science Center, Memphis, TN, USA \\
$^{\text{\sf 2}}$Genomics Research Centre, Human Technopole, Milan, Italy
}

\corresp{
$^\ast$To whom correspondence should be addressed. \\
% $^\dagger$Contributed equally.\
}

\history{Received on XXXXX; revised on XXXXX; accepted on XXXXX}

\editor{Associate Editor: XXXXXXX}

\abstract{
\textbf{Motivation:}
Pangenome graphs, often formally encoded as variation graphs, moodel the mutual alignment of collections of genomes.
A set of pairwise alignments imply a variation graph, but there are no scalable methods to generate such a graph or lossless string graph from these alignments.
Existing approaches depend on a single reference or a specific ordering of genomes, and do not provide base-level information about the mapping of genomes into the pangenome.
A scalable method to build pangenome graphs without such biases would be a key functional step in pangenome construction and manipulation pipelines. \\
\textbf{Results:}
We design the \textit{seqwish} algorithm, which builds variation graph from a set of sequences and alignments between them.
We first transform the alignment set into an interval tree.
To build up the variation graph, we query this tree-based representation of the alignments to reduce transitive matches into single DNA segments in a sequence graph.
By recording the mapping from input sequence to output graph, we can trace the original paths through this graph, yielding a pangenome graph.
We present an implementation that operates in external memory, using disk-backed implicit interval trees and a lock-free parallel algorithm to drive the core graph induction step.
We demonstrate that our method scales to very large graph induction problems, and apply our work to build graphs from dozens of genomes from the same or different species in clades throughout the tree of life. \\
\textbf{Availability:}
seqwish is published as free software under the MIT open source license.
Source code and documentation are available at \url{https://github.com/ekg/seqwish}.
seqwish can be installed via Bioconda \url{https://bioconda.github.io/recipes/seqwish/README.html} or GNU Guix \url{https://github.com/ekg/guix-genomics/blob/master/seqwish.scm}. \\
\textbf{Contact:} \href{egarris5@uthsc.edu}{egarris5@uthsc.edu} \\
%\textbf{Supplementary information:} Supplementary data are available at \textit{Bioinformatics} online.
}

\maketitle


\section{Introduction}
\label{sec:introduction}
A pangenome models the full genomic information of a species or clade \citep{Medini_2005,Sherman_2020}.
In contrast to reference-based approaches that relate sequences to a particular reference genome, methods that use pangenome reference systems attempt to model the mutual relationship between all represented genomes \citep{cpang2018}.
%These models encode the mutual relationships between all the genomes represented, in contrast to reference-based approaches which relate sequences only to a particular ``reference'' genome.
%In principle, pangenome graphs can allow for a great reduction in reference bias, allowing any part of a pangenome to be considered in biological studies. %, and may provide a simpler representation of structurally-variable regions.
Popular approaches model the pangenome alignment as a \textit{pangenome graph}.
Conceptually, the pangenome graph relates genomes as walks through and underlying DNA sequence language encoded as a sequence graph. 
In a pangenome graph, variation can be understood in the context of any part of any included genome, which lets us avoid the problem of reference bias, or a limitation of analyses to sequences that are very similar to a chosen reference genome \cite{Eizenga_2020}.

Surprisingly, existing methods to build pangenome graphs from large genome assemblies are reference-based.
Minigraph progressively builds a pangenome graph using by layering an ordered series of input genomes onto a specific reference \citep{Li:2020}.
Cactus depends on a single guide tree to structure pairwise alignments between genomes \citep{Armstrong:2020}.
Both kinds of methods limit computational costs by reducing the number of pairwise comparisons, but in turn their results depend on input genome order, selected reference, and guide-tree topology.

Although a reference-guided approach is pragmatic when we only have a single reference genome, in humans and other species recent advances in sequencing and assembly are driving the generation of many reference-quality assemblies \cite{Nurk_2021}.
Motivated by the need to generate ``multi-reference'' pangenome graphs, we develop \textit{seqwish}, an algorithm that allows us to build pangenome graphs directly from a collection of sequences and pairwise alignments between them.
Here, we formally describe the algorithm, evaluate its basic combinatoric bounds and costs, and present applications of the method to pangenome building problems in a variety of species.
%Our approach is both highly generic and scalable.
We can apply our method to any collection of sequences and alignments.
It easily scales to some of the largest species pangenome construction problems possible using publicly-available, high-quality genome assemblies.
%Not only is our approach highly generic,but it also efficiently scales to both large and complex pangenomes.
%with \textit{any} collection of alignments and sequences, 


%Given recent advances in genome sequencing and assembly, we expect that soon, many species will have multiple reference-quality genomes.
%To build a pangenome model from such genomes that is truly unbiased, we need an approach to build a multi-reference 
%Motivated by the current availability of two reference-quality human genome assemblies 
%The inability to build pangenome graphs from 

\section{Variation graph induction}
\label{sec:algorithm}

A class of methods to represent pangenomes involves the \textit{sequence graph} \citep{Hein_1989}, where identical segments of different genomes collapse into a single representative segment (often node) in the graph.
In \textit{node-labeled} sequence graphs, nodes indicate DNA sequences, with edges connecting the nodes that are concatenated in the sequences represented in the graph.
A \textit{bidirected} sequence graph represents both strands of DNA.
On this model, variation graphs add the concept of \textit{path} to embed linear sequences (e.g., genomes or haplotypes) into the graph \citep{Garrison_2018}.
Paths provide a stable coordinate system, allowing graph annotations and interoperability between different graphs.
A pangenome graph is a sequence model that encodes the mutual alignment of many genomes \citep{Eizenga_2020}.

\begin{definition}
\label{def:vg}
Variation graphs are a common formalism to encode pangenome graphs \citep{Garrison_2019_thesis}.
In the variation graph, $V = (N, E, P)$, nodes $N = n_1\ldots n_{|N|}$ contain sequences of DNA.
Each node $n_i$ has a unique numerical identifier $i$ and an implicit reverse complement $\bar{n_i}$.
A node strand $s$ corresponds to one node orientation.
Edges $E = e_1\ldots e_{|E|}$ connect ordered pairs of node strands: $e_i = ( s_a, s_b )$, encoding the base topology of the sequence graph.
Paths $P = p_1\ldots p_{|P|}$ describe walks over node strands: $p_i = s_1 \ldots s_{|p_i|}$, storing a collection of genomes written in terms of the sequence graph.
\end{definition}

\begin{theorem}
A variation graph represents pairwise alignments between its embedded paths.
\end{theorem}

\begin{proof}
By definition \ref{def:vg}, two paths have identical subsequences where they walk (or ``step'') through the same series of oriented nodes (e.g. $s_1 s_2 s_3$).
An identical set of path steps is thus equivalent to a sequence match.
Pairwise alignments are by definition collections of matches between sequences.
The variation graph thus models a set of pairwise alignments between paths in $P$.
\end{proof}

\begin{theorem}
We can construct a variation graph from pairwise alignments.
\end{theorem}

This follows from \ref{def:vg}.
Our input $Q = S \vee \bar{S}$ is a set of $N$ DNA sequences $S = g_1 \ldots g_N$ and their reverse complements $\bar{S} = \bar{g_1} \ldots \bar{g_N}$.
%Assume that $i$ and $j$ are coordinates in $Q$.
A match $m = (i, j)$ asserts the evolutionary equivalence of two charaters in sequences in $Q$.
%$\forall_{(i, j) : j = |g| - i} g[i] = \bar{g}[j]$.
Pairwise alignments between sequences in $Q$ are a set of matches $A = \{ m_1 \ldots m_{|A|} \}$.
By standard definition, each sequence matches its own reverse complement: $g[i] = \bar{g}[j]$ for all $j = |g| - i$, and we assume these matches are included in $A$.
%A match $m$ can be understood as a component in a binary relation.
The transitive closure of a match, $m^+ = \{ i \ldots j \}$, is a set of characters in $Q$ that are transitively linked together by other matches.
By definition of $m$, each $m^+$ implies a single, identical character $c(m^+)$.

We build a graph $V$ inductively.
We take the first match in $A$, $m_1$, and execute a union-find operation to obtain $m_1^+$.
We add the character of the match $c(m_1^+)$ as a node $n_1$ in $V$, record the mapping from $m_1^+ \to n_1$.
To induce the graph, we take the next un-used match in $A : m_i \notin \forall_{j < i} m_j^+$, obtain $m_i^+$, and add $c(m_i^+)$ to $V$.
To allow the annotation of paths, we record the set of characters in $Q$ that match to a given node in $V$ in mapping $Z = Q \to V$
We continue until all matches have been used.
Finally, we establish paths ($P$) by walking them in $V$ using $Z$, and record edges ($E$) where nodes occur successively in paths.

\begin{proof}
After the first step of induction, the graph represents all pairwise matches in $m_1^+$.
Each subsequent step includes progressively more of $A$, until at completion, all pairwise relationships are accounted for in $V$.
The paths of the variation graph are equivalent to input sequences, and the path relationship within the graph is defined by their alignments.
\end{proof}

The set of alignments represented by a variation graph is strictly larger than the set of alignments used to induce it.
The graph must contain at least the set of alignments given on input.
It may also contain new implied pairwise relationships that arise due to transitive match relationships, as shown in closures 1 and 6 in Figure \ref{fig:induction}.
However, it cannot contain less match information than represented in $A$, by definition of $V$.


\input{fig_from_alignment_to_variation_graph.tex}


\section{Algorithm}



\section{Implementation}


\begin{comment}



\subsection{Sequence input}


Using a compressed suffix array (CSA) over sequence names, we build an index that maps between offsets in all genomes and offsets in $Q$ via lookup of the sequence name in the CSA.
This allows us to map between positions in the sequences of $Q$, which is the format in which alignment algorithms typically express alignments, and positions in $Q$ itself, which is the coordinate space we will use as a basis for the generation of our graph.

\subsection{Alignment graph}

Alignments between genomes imply a set of exact matches between subsequences of $Q$, which we represent as interval pairs $m := ((q_b, q_e), (t_b, t_e))$.
We encode the $X$ matches in a set of alignments made by an external method \cite{wfmash,Li_2018} in $A = m_1 \ldots m_X$.
\citep{Li_bedtk_2020}.

%\FIXME{To integrate to the text
The alignment graph formalizes the collection of alignments between genomes.
In this graph, each base pair in the input genomes is represented by a node.
Two kinds of edges connect these nodes.
The first ``precedence'' edge type indicates successive pairs of base pairs in the input, linking together the input genomes within the alignment graph.
The second “match” type of edge links nodes that alignment has asserted to be matches.

We encode the set of input pairwise alignments between sequences in $Q$ as object $A$.
Although these alignments tend to be represented using oriented interval pairs in $Q$, for simplicity and robustness to graph complexity, we describe $A$ as a set of pairs of bidirectional positions (sequence offsets and strands) $[1 \ldots |Q_1 \ldots Q_{|Q|}|]$ , such that $A = \{ (b_{q}, b_{r}), \ldots \}$.
We sort $A$ by the first member ($b_{q}$) of each pair, ensuring that the entries in $A$ are ordered according to their order in $Q$.

To query the induced graph we build a rank/select dictionary allowing efficient traversal of $A$, based on a bit vector $A_{bv}$ of the same length as $A$ such that we record a 1 at those positions which correspond to the first instance of a given $b_{q}$ and record a 0 in $A_{bv}$ otherwise.
We record which $b_{q}$ we have processed in the bitvector $Q_{seen}$ which is of the same length as $Q$.
This allows us to avoid a quadratic penalty in the order of the size of the transitive closures in $Q$ generated by pairs in $A$.

Now we inductively derive the graph implied by the alignments.
For each base $b_{q}$ in $Q$ not already marked in $Q_{seen}$, we find its transitive closure $c_{q} := \{b_{q}, b_{r_{1}}, \ldots \}$ by traversing aligned base pairs recorded in $A$.
We write the character of the base $b_{q}$ to an entry $s_i$ in a vector $S$, then for each $b_{c}$ in $c_{q}$ we record a pair $(s_{i}, b_{c})$ into $N$ and its reverse, $(b_{c}, s_{i})$ into $P$.
We mark $Q_{seen}$ for each base in each emitted cluster, so that we will not consider these bases in subsequent transitive closures.
By sorting $N$ and $P$ by their first entries, we can build rank/select dictionaries on them akin to that we built on $A$ that allow random access by graph base (as given in $S$) or input base (as given in $Q$).

\subsection{Sequence graph}

The alignment graph may be converted into a basic sequence graph by condensing all sets of nodes that are transitively linked by match edges.



\subsection{Variation graph}

By recording the relationship between sequence graph and alignment graph nodes, we are able to trace the paths of pangenome sequences through the graph, producing our target: a pangenome variation graph that completely describes both the input assemblies and their alignments (Fig.~\ref{fig:from_alignment_to_variation_graph}).


Seqwish implements a lossless conversion from pairwise alignments between sequences to a variation graph encoding the sequences and their alignments.
As input, we typically take all-versus-all alignments, but the exact structure of the alignment set may be defined in an application specific way.
Seqwish uses a series of disk-backed sorts and passes over the alignment and sequence inputs to allow the graph to be constructed in low memory relative to the size of the input sequence set.
Memory usage during construction and traversal is limited by the use of sorted disk-backed arrays and succinct rank/select dictionaries to record a queryable version of the graph.

\section{Seqwish implementation}
\label{sec:implementation}

We need to establish the links between bases in $S$ that would be required for us to find any sequence in the input as a walk through the graph.
We do so by rewriting $Q$ (in both the forward and reverse orientation) in terms of pairs of bases in $S$, then sorting the resulting pairs by their first element, which yields $L = [(b_{a}, b_{b}), \ldots ]$.
In typical use we take the edges of the graph to be given by the unique elements of $L$.

Our data model encodes the graph using single-base nodes, but often downstream use requires identifying nodes and thus we benefit from compressing the unitigs of the graph into single nodes, which reduces memory used by identifiers in analysis.
We can compress the node space of the graph by traversing $S$, and for each base querying the inbound links.
Maintaining a bitvector $S_{id}$ of length equal to $S$ we mark each base at which we see any link other than one from or to the previous base on the forward or reverse strand, or at bases where we have no incoming links.
By building a rank/select dictionary on $S_{id}$ we can assign a smaller set of node ids to the sequence space of the graph.

Given the id space encoded by $S_{id}$ we can materialize the graph in a variety of interchange formats, or provide id-based interfaces to the indexed squish graph.
To generate graphs in \texttt {vg} or GFA format, we want to decompose the graph into its nodes ($S$), edges ($L$) and paths ($P$).
The nodes are given by $S$ and $S_{id}$, and similarly we project $L$ and $P$ through $S_{id}$ to obtain a compressed variation graph.

\end{comment}

%    \FIXME{To integrate to the text}
%    To support this kind of data scale, we implement \texttt{seqwish}'s algorithm using disk-backed memory.
%    We write the alignment graph into a disk-backed implicit interval tree, wherein each match in the input alignments is a queryable range.
%    A lock-free, parallel union-find algorithm \FIXME{Wait-free parallel algorithms for the union-find problem} allows us to, for each base pair of input sequence, collect all other base pairs in the pangenome that are aligned to it.
%    By processing this transitive closure operation in chunks (\textit{e.g.} 10Mbp at a time), we limit the maximum working memory (RAM) requirements of the process without affecting the output.
%    After the transitive closure, we write our final graph on disk in a set of arrays, then augment it with the paths of our input sequences,
%    finally emitting the resulting graph in the standard Graphical Fragment Assembly (GFA) format~\citep{GFA}.


    \section{Results}
    \label{sec:results}
    \FIXME{to do}

    %The alignment is taken as truth, so some of the cross validation things we do for pggb are irrelevant.
    %The one experiment could be graph induction on many graphs, with a 2D/3D plot with input size (alignments) vs induction time and color/shape to show graph output size or something
    %Or
    %We go schematic with the figure to show a complex but very detailed example with the algorithm worked out

    %    \subsection{subsection 1}
    %\label{subsec:subsec1}
    %\FIXME{to do}


    \section{Discussion}
    \label{sec:discussion}
    \FIXME{to do}

    \section*{Acknowledgements}

    We thank Richard Durbin, Benedict Paten, and Simon Puglisi for support and helpful discussions in the development of this algorithm.
    %We are greatful to members of the HPRC production teams for their development of resources used in our exposition.

    \section*{Funding}

    We gratefully acknowledge support from NIH/NIDA U01DA047638 (EG).

    \section*{Data availability}

    Code and links to data resources used to build this manuscript and its figures, can be found in the paper's public repository: \url{https://github.com/pangenome/seqwish-paper}.

    \bibliographystyle{natbib}

    \bibliography{document}

\end{document}
