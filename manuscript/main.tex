\PassOptionsToPackage{utf8}{inputenc}
\documentclass{bioinfo}

\usepackage[draft]{hyperref}
\usepackage{makecell}
\usepackage{comment}

\usepackage{floatrow}

% singlelinecheck=false puts subcaptions on the left
\usepackage[singlelinecheck=false]{subcaption}

\usepackage{algorithm2e}
\usepackage[usenames,dvipsnames]{xcolor}

% we squeeze our figures even more together
\captionsetup{belowskip=-2pt}

\SetAlgoLined
\SetKwProg{MyStruct}{Struct}{ contains}{end}

\newcommand{\vocab}{\textbf}
\newcommand{\red}[1]{{\textcolor{Red}{#1}}}
\newcommand{\FIXME}[1]{\red{[FIXME: #1]}}

\def\labelitemi{--}

\copyrightyear{2021} \pubyear{XXXX}

\access{Advance Access Publication Date: Day Month Year}
\appnotes{Genome Analysis}

\begin{document}
\firstpage{1}

\subtitle{Genome Analysis}

\title[Multi-reference pangenome graphs]{Multi-reference pangenome graphs}
\author[Garrison \textit{et~al}.]{
Erik~Garrison\,$^{\text{\sfb 1}*}$,
Andrea~Guarracino\,$^{\text{\sfb 2}}$
}

\address{
$^{\text{\sf 1}}$University of Tennessee Health Science Center, Memphis, TN, USA \\
$^{\text{\sf 2}}$Genomics Research Centre, Human Technopole, Milan, Italy
}

\corresp{
$^\ast$To whom correspondence should be addressed. \\
% $^\dagger$Contributed equally.\
}

\history{Received on XXXXX; revised on XXXXX; accepted on XXXXX}

\editor{Associate Editor: XXXXXXX}

\abstract{
\textbf{Motivation:}
Pangenome graphs provide a complete representation of the mutual alignment of collections of genomes.
They are commonly modeled as variation graphs.
A set of pairwise alignments imply a variation graph, but, to our knowledge, there are no methods to generate such a graph or lossless string graph from these alignments. \\
\textbf{Results:}
We design the \textit{seqwish} algorithm, which builds variation graph from a set of sequences and alignments between them.
Our seqwish implementation operates in external memory, using disk-backed implicit interval trees and a lock-free parallel union find algorithm to transform the alignment set into an alignment graph, then a sequence graph, and finally a variation graph with paths representing the input sequences.
%        use of this graph in the elaboration of the variation graph including paths representing the input sequences.
The resulting graph is a lossless representation of the input and its alignments.\\
\textbf{Availability:}
seqwish is published as free software under the MIT open source license.
Source code and documentation are available at \url{https://github.com/ekg/seqwish}.
seqwish can be installed via Bioconda \url{https://bioconda.github.io/recipes/seqwish/README.html} or GNU Guix \url{https://github.com/ekg/guix-genomics/blob/master/seqwish.scm}. \\
\textbf{Contact:} \href{egarris5@uthsc.edu}{egarris5@uthsc.edu} \\
%\textbf{Supplementary information:} Supplementary data are available at \textit{Bioinformatics} online.
}

\maketitle


\section{Introduction}
\label{sec:introduction}
A pangenome models the full genomic information of a species or clade~\FIXME{PMID:32034321}.
These models encode the mutual relationships between all the genomes represented, in contrast to reference-based approaches which relate sequences only to a particular ``reference'' genome.
%In principle, pangenome graphs can allow for a great reduction in reference bias, allowing any part of a pangenome to be considered in biological studies. %, and may provide a simpler representation of structurally-variable regions.
In a pangenome graph, variation can be understood in the context of any part of any included genome, which lets us avoid the problem of reference bias, or a limitation of analyses to sequences that are very similar to a chosen reference genome.

Surprisingly, existing methods to build pangenome graphs from large genome assemblies are reference-based.
Minigraph progressively builds a pangenome graph using by layering an ordered series of input genomes onto a specific reference.
Cactus depends on a single guide tree to structure pairwise alignments between genomes.
Both kinds of methods limit computational costs by reducing the number of pairwise comparisons, but in turn their results exhibit order and reference-dependency.

Although a reference-guided approach is pragmatic when we only have a single reference genome, in humans and other species recent advances in sequencing and assembly are driving the generation of many reference-quality assemblies.
Motivated by the need to generate ``multi-reference'' pangenome graphs, we present \textit{seqwish}, an algorithm that allows us to build pangenome graphs directly from a collection of sequences and pairwise alignments between them.
Here, we formally describe the algorithm, evaluate its basic combinatoric bounds and costs, and present applications of the method to pangenome building problems in a variety of species.
Our approach is both highly generic---in that we can apply it to truly any collection of sequences and alignments---but it easily scales to some of the largest species pangenome construction problems possible using publicly-available, high-quality genome assemblies.
%Not only is our approach highly generic,but it also efficiently scales to both large and complex pangenomes.
%with \textit{any} collection of alignments and sequences, 


%Given recent advances in genome sequencing and assembly, we expect that soon, many species will have multiple reference-quality genomes.
%To build a pangenome model from such genomes that is truly unbiased, we need an approach to build a multi-reference 
%Motivated by the current availability of two reference-quality human genome assemblies 
%The inability to build pangenome graphs from 

\section{Model}
    \label{sec:model}

A class of methods to represent pangenomes involves the \textit{sequence graphs} \FIXME{PMID:2488477}, where similar orthologous regions between genomes collapse into a single representative component in the graph.
In \textit{node-labeled} sequence graphs, nodes indicate DNA sequences, with edges connecting the nodes that are concatenated in the sequences represented in the graph.
A \textit{bidirected} sequence graph represents both strands of DNA.
On this model, variation graphs add the concept of \textit{path} to embed linear sequences (e.g., genomes or haplotypes) into the graph\citep{Garrison:2018}.
Paths provide a stable coordinate system, allowing graph annotations and interoperability between different graphs.


    A pangenome graph is a sequence model that encodes the mutual alignment of many genomes~\citep{Garrison_2019_thesis,Eizenga_2020}.
    In the variation graph, $V = (N, E, P)$, nodes $N = n_1\ldots n_{|N|}$ contain sequences of DNA.
    Each node $n_i$ has an identifier $i$ and an implicit reverse complement $\bar{n_i}$, and a node strand $s$ corresponds to one such orientations.
    Edges $E = e_1\ldots e_{|E|}$ represent ordered pairs of node strands: $e_i = ( s_a, s_b )$.
    Paths $P = p_1\ldots p_{|P|}$ describe walks over node strands: $p_i = s_1 \ldots s_{|p_i|}$.

    A set of pairwise alignments imply a variation graph, however, to our knowledge, there is no contained method that can
    generate the variation graph or lossless string graph from large input alignments.
    To explore this, we developed an algorithm to do so that operates in external memory by conversion of the alignment
    set into an alignment graph and the subsequent use of this graph in the elaboration of the variation graph including paths representing the input sequences.
    The resulting graph is a lossless representation of the input and the alignments between them.
    To distinguish the approach from string graphs, which imply error correction, we call this variation graph induction model the \emph{squish graph}.

    \FIXME{To integrate to the text} The alignment graph formalizes the collection of alignments between genomes.
    In this graph, each base pair in the input genomes is represented by a node.
    Two kinds of edges connect these nodes.
    The first `precedence' edge type indicates successive pairs of base pairs in the input,
    linking together the input genomes within the alignment graph.
    The second “match” type of edge links nodes that alignment has asserted to be matches.
    The alignment graph may be converted into a basic sequence graph by condensing all sets of nodes that are transitively linked by match edges.
    By recording the relationship between sequence graph and alignment graph nodes, we are able to trace the paths of pangenome sequences through the
    graph, producing our target: a pangenome variation graph that completely describes both the input assemblies and their alignments (Fig.~\ref{fig:from_alignment_to_variation_graph}).

    \texttt{seqwish} implements a lossless conversion from pairwise alignments between sequences to a variation graph encoding the sequences and their alignments.
    As input, we typically take all-versus-all alignments, but the exact structure of the alignment set may be defined in an application specific way.
    \texttt{seqwish} uses a series of disk-backed sorts and passes over the alignment and sequence inputs to allow the graph to be constructed in low memory relative to the size of the input sequence set.
    Memory usage during construction and traversal is limited by the use of sorted disk-backed arrays and succinct rank/select dictionaries to record a queryable version of the graph.

    \input{fig_from_alignment_to_variation_graph.tex}


    \section{Implementation}
    \label{sec:implementation}

    \FIXME{The algorithm validates some aspects of itself, we should point that out}

    As input, we have $Q$, which is a concatenation of the sequences from which we will build the graph.
    We build a compressed suffix array (CSA) mapping sequence names to offsets in $Q$, and also the inverse using a rank/select dictionary on a bitvector marking the starts of sequences in $Q$.
    This allows us to map between positions in the sequences of $Q$, which is the format in which alignment algorithms typically express alignments, and positions in $Q$ itself, which is the coordinate space we will use as a basis for the generation of our graph.
    We encode the set of input pairwise alignments between sequences in $Q$ as object $A$.
    Although these alignments tend to be represented using oriented interval pairs in $Q$, for simplicity and robustness to graph complexity, we describe $A$ as a set of pairs of bidirectional positions (sequence offsets and strands) $[1 \ldots |Q_1 \ldots Q_{|Q|}|]$ , such that $A = \{ (b_{q}, b_{r}), \ldots \}$.
    We sort $A$ by the first member ($b_{q}$) of each pair, ensuring that the entries in $A$ are ordered according to their order in $Q$.

    To query the induced graph we build a rank/select dictionary allowing efficient traversal of $A$, based on a bit vector $A_{bv}$ of the same length as $A$ such that we record a 1 at those positions which correspond to the first instance of a given $b_{q}$ and record a 0 in $A_{bv}$ otherwise.
    We record which $b_{q}$ we have processed in the bitvector $Q_{seen}$ which is of the same length as $Q$.
    This allows us to avoid a quadratic penalty in the order of the size of the transitive closures in $Q$ generated by pairs in $A$.

    Now we inductively derive the graph implied by the alignments.
    For each base $b_{q}$ in $Q$ not already marked in $Q_{seen}$, we find its transitive closure $c_{q} := \{b_{q}, b_{r_{1}}, \ldots \}$ by traversing aligned base pairs recorded in $A$.
    We write the character of the base $b_{q}$ to an entry $s_i$ in a vector $S$, then for each $b_{c}$ in $c_{q}$ we record a pair $(s_{i}, b_{c})$ into $N$ and its reverse, $(b_{c}, s_{i})$ into $P$.
    We mark $Q_{seen}$ for each base in each emitted cluster, so that we will not consider these bases in subsequent transitive closures.
    By sorting $N$ and $P$ by their first entries, we can build rank/select dictionaries on them akin to that we built on $A$ that allow random access by graph base (as given in $S$) or input base (as given in $Q$).

    To fully induce the variation graph we need to establish the links between bases in $S$ that would be required for us to find any sequence in the input as a walk through the graph.
    We do so by rewriting $Q$ (in both the forward and reverse orientation) in terms of pairs of bases in $S$, then sorting the resulting pairs by their first element, which yields $L = [(b_{a}, b_{b}), \ldots ]$.
    These pairs record the links and their frequencies, which we can emit or filter (such as by frequency) as needed in particular applications.
    In typical use we take the graph to be given by the unique elements of $L$.

    Our data model encodes the graph using single-base nodes, but often downstream use requires identifying nodes and thus we benefit from compressing the unitigs of the graph into single nodes, which reduces memory used by identifiers in analysis.
    We can compress the node space of the graph by traversing $S$, and for each base querying the inbound links.
    Maintaining a bitvector $S_{id}$ of length equal to $S$ we mark each base at which we see any link other than one from or to the previous base on the forward or reverse strand, or at bases where we have no incoming links.
    By building a rank/select dictionary on $S_{id}$ we can assign a smaller set of node ids to the sequence space of the graph.

    Given the id space encoded by $S_{id}$ we can materialize the graph in a variety of interchange formats, or provide id-based interfaces to the indexed squish graph.
    To generate graphs in \texttt {vg} or GFA format, we want to decompose the graph into its nodes ($S$), edges ($L$) and paths ($P$).
    The nodes are given by $S$ and $S_{id}$, and similarly we project $L$ and $P$ through $S_{id}$ to obtain a compressed variation graph.

    \FIXME{To integrate to the text}
    To support this kind of data scale, we implement \texttt{seqwish}'s algorithm using disk-backed memory.
    We write the alignment graph into a disk-backed implicit interval tree, wherein each match in the input alignments is a queryable range.
    A lock-free, parallel union-find algorithm \FIXME{Wait-free parallel algorithms for the union-find problem} allows us to, for each base pair of input sequence, collect all other base pairs in the pangenome that are aligned to it.
    By processing this transitive closure operation in chunks (\textit{e.g.} 10Mbp at a time), we limit the maximum working memory (RAM) requirements of the process without affecting the output.
    After the transitive closure, we write our final graph on disk in a set of arrays, then augment it with the paths of our input sequences,
    finally emitting the resulting graph in the standard Graphical Fragment Assembly (GFA) format~\citep{GFA}.


    \section{Results}
    \label{sec:results}
    \FIXME{to do}

    %The alignment is taken as truth, so some of the cross validation things we do for pggb are irrelevant.
    %The one experiment could be graph induction on many graphs, with a 2D/3D plot with input size (alignments) vs induction time and color/shape to show graph output size or something
    %Or
    %We go schematic with the figure to show a complex but very detailed example with the algorithm worked out

    \subsection{subsection 1}
    \label{subsec:subsec1}
    \FIXME{to do}


    \section{Discussion}
    \label{sec:discussion}
    \FIXME{to do}

    \section*{Acknowledgements}

    We thank members of the HPRC production teams for their development of resources used in our exposition.

    \section*{Funding}

    We gratefully acknowledge support from NIH/NIDA U01DA047638 (EG).

    \section*{Data availability}

    Code and links to data resources used to build this manuscript and its figures, can be found in the paper's public repository: \url{https://github.com/pangenome/seqwish-paper}.

    \bibliographystyle{natbib}

    \bibliography{document}

\end{document}
